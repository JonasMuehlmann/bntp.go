// Copyright Â© 2021-2022 Jonas Muehlmann
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// THIS CODE IS GENERATED BY GO GENERATE, IT'S TEMPLATE IS /templates/document.go.tpl

{{$StructName := .StructName}}
package domain

import (
	"time"

	"github.com/JonasMuehlmann/optional.go"
	"github.com/JonasMuehlmann/bntp.go/model"
)


{{$StructName :=  .StructName -}}

type {{.StructName}} struct {
    {{range $field := .StructFields}}
    {{.FieldName}} {{.FieldType}} {{.FieldTags -}}
    {{end}}
}


func (t *{{.StructName}}) IsDefault() bool {
    {{range $field := .StructFields -}}
    {{ if eq "[" (slice .FieldType 0 1) }}
    if t.{{.FieldName}} != nil {
    {{ else }}
    var {{.FieldName}}Zero {{.FieldType}}
    if t.{{.FieldName}} != {{.FieldName}}Zero {
    {{ end }}
        return false
    }
    {{end}}

    return true
}

type {{.StructName}}Field string

var {{.StructName}}Fields = struct {
    {{range $field := .StructFields -}}
    {{.FieldName}}  {{$StructName}}Field
    {{end}}
}{
    {{range $field := .StructFields -}}
    {{.FieldName}}: "{{.LogicalFieldName -}}",
    {{end}}
}

{{range $field := .StructFields -}}
func (document *{{$StructName}}) Get{{.FieldName}}() {{.FieldType}} {
        return document.{{.FieldName}}
}
{{end}}
{{range $field := .StructFields -}}
func (document *{{$StructName}}) Get{{.FieldName}}Ref() *{{.FieldType}} {
        return &document.{{.FieldName}}
}
{{end}}

type {{.StructName}}Filter struct {
    {{range $field := .StructFields -}}
    {{.FieldName}} optional.Optional[model.FilterOperation[{{Unslice (UnaliasSQLBoilerSlice .FieldType)}}]]
    {{end}}
}

func (filter *{{.StructName}}Filter) IsDefault() bool {
    {{range $field := .StructFields -}}
    if filter.{{.FieldName}}.HasValue {
        return false
    }
    {{end}}

    return true
}


type {{$.StructName}}Updater struct {
    {{range $field := .StructFields -}}
    {{.FieldName}} optional.Optional[model.UpdateOperation[{{.FieldType}}]]
    {{end}}
}

func (updater *{{.StructName}}Updater) IsDefault() bool {
    {{range $field := .StructFields -}}
    if updater.{{.FieldName}}.HasValue {
        return false
    }
    {{end}}

    return true
}

const (
    {{.StructName}}FilterUntagged = "{{.StructName}}FilterUntagged"
    {{.StructName}}FilterDeleted = "{{.StructName}}FilterDeleted"
)

// FIX: This operating on int64s instead of the slice is nonsense, right?
var Predefined{{.StructName}}Filters = map[string]{{.StructName}}Filter {
    {{.StructName}}FilterUntagged: {TagIDs: optional.Make(model.FilterOperation[int64]{
        Operand: model.ScalarOperand[int64]{
            Operand: -1,
        },
        Operator: model.FilterEqual,
    })},
    {{.StructName}}FilterDeleted: {DeletedAt: optional.Make(model.FilterOperation[optional.Optional[time.Time]]{
        Operand: model.ScalarOperand[optional.Optional[time.Time]]{
            Operand: optional.Optional[time.Time]{},
        },
        Operator: model.FilterEqual,
    })},
}
