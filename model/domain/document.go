// Copyright Â© 2021-2022 Jonas Muehlmann
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// THIS CODE IS GENERATED BY GO GENERATE, IT'S TEMPLATE IS /templates/document.go.tpl


package domain

import (
	"time"

	"github.com/JonasMuehlmann/optional.go"
	"github.com/JonasMuehlmann/bntp.go/model"
)


type Document struct {
    
    CreatedAt time.Time `json:"created_at" toml:"created_at" yaml:"created_at"`
    UpdatedAt time.Time `json:"updated_at" toml:"updated_at" yaml:"updated_at"`
    DeletedAt optional.Optional[time.Time] `json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
    Path string `json:"path" toml:"path" yaml:"path"`
    DocumentType optional.Optional[string] `json:"document_type" toml:"document_type" yaml:"document_type"`
    Tags []*Tag `json:"Tags" toml:"Tags" yaml:"Tags"`
    LinkedDocuments []*Document `json:"linked_documents" toml:"linked_documents" yaml:"linked_documents"`
    BacklinkedDocuments []*Document `json:"backlinked_documents" toml:"backlinked_documents" yaml:"backlinked_documents"`
    ID int64 `json:"id" toml:"id" yaml:"id"`
}

type DocumentField string

var DocumentFields = struct {
    CreatedAt  DocumentField
    UpdatedAt  DocumentField
    DeletedAt  DocumentField
    Path  DocumentField
    DocumentType  DocumentField
    Tags  DocumentField
    LinkedDocuments  DocumentField
    BacklinkedDocuments  DocumentField
    ID  DocumentField
    
}{
    CreatedAt: "created_at",
    UpdatedAt: "updated_at",
    DeletedAt: "deleted_at",
    Path: "path",
    DocumentType: "document_type",
    Tags: "Tags",
    LinkedDocuments: "linked_documents",
    BacklinkedDocuments: "backlinked_documents",
    ID: "id",
    
}

type DocumentFilter struct {
    CreatedAt optional.Optional[model.FilterOperation[time.Time]]
    UpdatedAt optional.Optional[model.FilterOperation[time.Time]]
    DeletedAt optional.Optional[model.FilterOperation[optional.Optional[time.Time]]]
    Path optional.Optional[model.FilterOperation[string]]
    DocumentType optional.Optional[model.FilterOperation[optional.Optional[string]]]
    Tags optional.Optional[model.FilterOperation[*Tag]]
    LinkedDocuments optional.Optional[model.FilterOperation[*Document]]
    BacklinkedDocuments optional.Optional[model.FilterOperation[*Document]]
    ID optional.Optional[model.FilterOperation[int64]]
    
}

func (filter *DocumentFilter) IsDefault() bool {
    if filter.CreatedAt.HasValue {
        return false
    }
    if filter.UpdatedAt.HasValue {
        return false
    }
    if filter.DeletedAt.HasValue {
        return false
    }
    if filter.Path.HasValue {
        return false
    }
    if filter.DocumentType.HasValue {
        return false
    }
    if filter.Tags.HasValue {
        return false
    }
    if filter.LinkedDocuments.HasValue {
        return false
    }
    if filter.BacklinkedDocuments.HasValue {
        return false
    }
    if filter.ID.HasValue {
        return false
    }
    

    return true
}


type DocumentUpdater struct {
    CreatedAt optional.Optional[model.UpdateOperation[time.Time]]
    UpdatedAt optional.Optional[model.UpdateOperation[time.Time]]
    DeletedAt optional.Optional[model.UpdateOperation[optional.Optional[time.Time]]]
    Path optional.Optional[model.UpdateOperation[string]]
    DocumentType optional.Optional[model.UpdateOperation[optional.Optional[string]]]
    Tags optional.Optional[model.UpdateOperation[[]*Tag]]
    LinkedDocuments optional.Optional[model.UpdateOperation[[]*Document]]
    BacklinkedDocuments optional.Optional[model.UpdateOperation[[]*Document]]
    ID optional.Optional[model.UpdateOperation[int64]]
    
}

func (updater *DocumentUpdater) IsDefault() bool {
    if updater.CreatedAt.HasValue {
        return false
    }
    if updater.UpdatedAt.HasValue {
        return false
    }
    if updater.DeletedAt.HasValue {
        return false
    }
    if updater.Path.HasValue {
        return false
    }
    if updater.DocumentType.HasValue {
        return false
    }
    if updater.Tags.HasValue {
        return false
    }
    if updater.LinkedDocuments.HasValue {
        return false
    }
    if updater.BacklinkedDocuments.HasValue {
        return false
    }
    if updater.ID.HasValue {
        return false
    }
    

    return true
}

const (
    DocumentFilterUntagged = "DocumentFilterUntagged"
    DocumentFilterDeleted = "DocumentFilterDeleted"
)

var PredefinedDocumentFilters = map[string]DocumentFilter {
    DocumentFilterUntagged: {Tags: optional.Make(model.FilterOperation[*Tag]{
        Operand: model.ScalarOperand[*Tag]{
            Operand: nil,
        },
        Operator: model.FilterEqual,
    })},
    DocumentFilterDeleted: {DeletedAt: optional.Make(model.FilterOperation[optional.Optional[time.Time]]{
        Operand: model.ScalarOperand[optional.Optional[time.Time]]{
            Operand: optional.Optional[time.Time]{},
        },
        Operator: model.FilterEqual,
    })},
}
