// Copyright Â© 2021-2022 Jonas Muehlmann
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// THIS CODE IS GENERATED BY GO GENERATE, IT'S TEMPLATE IS /templates/sql_repositories/bookmark_repository.go.tpl

package repository

import (
    "database/sql"
	"github.com/JonasMuehlmann/bntp.go/repository"
    "context"
    "github.com/volatiletech/sqlboiler/v4/boil"
)

type PsqlBookmarkRepository struct {
    db sql.DB
}
type BookmarkField string

var BookmarkFields = struct {
    ID  BookmarkField
    IsRead  BookmarkField
    Title  BookmarkField
    URL  BookmarkField
    BookmarkTypeID  BookmarkField
    IsCollection  BookmarkField
    CreatedAt  BookmarkField
    UpdatedAt  BookmarkField
    DeletedAt  BookmarkField
    
}{
    ID: "id",
    IsRead: "is_read",
    Title: "title",
    URL: "url",
    BookmarkTypeID: "bookmark_type_id",
    IsCollection: "is_collection",
    CreatedAt: "created_at",
    UpdatedAt: "updated_at",
    DeletedAt: "deleted_at",
    
}

var BookmarkFieldsList = []BookmarkField{
    BookmarkField("ID"),
    BookmarkField("IsRead"),
    BookmarkField("Title"),
    BookmarkField("URL"),
    BookmarkField("BookmarkTypeID"),
    BookmarkField("IsCollection"),
    BookmarkField("CreatedAt"),
    BookmarkField("UpdatedAt"),
    BookmarkField("DeletedAt"),
    
}

var BookmarkRelationsList = []string{
    "BookmarkType",
    "Tags",
    
}

type BookmarkFilter struct {
    ID optional.Optional[FilterOperation[int64]]
    IsRead optional.Optional[FilterOperation[int64]]
    Title optional.Optional[FilterOperation[null.String]]
    URL optional.Optional[FilterOperation[string]]
    BookmarkTypeID optional.Optional[FilterOperation[null.Int64]]
    IsCollection optional.Optional[FilterOperation[int64]]
    CreatedAt optional.Optional[FilterOperation[string]]
    UpdatedAt optional.Optional[FilterOperation[string]]
    DeletedAt optional.Optional[FilterOperation[null.String]]
    
    BookmarkType optional.Optional[UpdateOperation[*repository.BookmarkType]]
    Tags optional.Optional[UpdateOperation[repository.TagSlice]]
    
}

type BookmarkUpdater struct {
    ID optional.Optional[UpdateOperation[int64]]
    IsRead optional.Optional[UpdateOperation[int64]]
    Title optional.Optional[UpdateOperation[null.String]]
    URL optional.Optional[UpdateOperation[string]]
    BookmarkTypeID optional.Optional[UpdateOperation[null.Int64]]
    IsCollection optional.Optional[UpdateOperation[int64]]
    CreatedAt optional.Optional[UpdateOperation[string]]
    UpdatedAt optional.Optional[UpdateOperation[string]]
    DeletedAt optional.Optional[UpdateOperation[null.String]]
    
    BookmarkType optional.Optional[UpdateOperation[*repository.BookmarkType]]
    Tags optional.Optional[UpdateOperation[repository.TagSlice]]
    
}

type PsqlBookmarkRepositoryHook func(context.Context, PsqlBookmarkRepository) error

func (repo * PsqlBookmarkRepository) New(args ...any) (PsqlBookmarkRepository, error) {
        panic("not implemented") // TODO: Implement
}

func (repo *PsqlBookmarkRepository) Add(ctx context.Context, repositoryModels []Bookmark) error {
	tx, err := repo.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	for _, repositoryModel := range repositoryModels {
		err = repositoryModel.Insert(ctx, tx, boil.Infer())
		if err != nil {
			return err
		}
	}

	tx.Commit()

    return nil
}

func (repo *PsqlBookmarkRepository) Replace(ctx context.Context, repositoryModels []Bookmark) error {
	repositoryModels := make([]Bookmark, 0, len(repositoryModels))

	for _, repositoryModel := range repositoryModels {
        repositoryModel, err := BookmarkrepositoryToSqlRepositoryModel(&repo.db, repositoryModel)
		if err != nil {
			return err
		}

		repositoryModels = append(repositoryModels, repositoryModel)
	}

	tx, err := repo.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	for _, repositoryModel := range repositoryModels {
		_, err = repositoryModel.Update(ctx, tx, boil.Infer())
		if err != nil {
			return err
		}
	}

	tx.Commit()

    return nil
}

func (repo *PsqlBookmarkRepository) UpdateWhere(ctx context.Context, columnFilter BookmarkFilter, columnUpdaters map[BookmarkField]BookmarkUpdater) (numAffectedRecords int, err error) {
    // NOTE: This kind of update is inefficient, since we do a read just to do a write later, but at the moment there is no better way
    // Either SQLboiler adds support for this usecase or (preferably), we use the caching and hook system to avoid database interaction, when it is not needed

    // NOTE: Maybe the filter and update operations should be moved to the repository package
    // The repository functions maybe should take repository models as parameters then,
    // the managers take repository models and convert then to repository models before calling the repositories

    // TODO: Implement translator from domainColumnFilter to repositoryColumnFilter and updater

}

func (repo *PsqlBookmarkRepository) Delete(ctx context.Context, repositoryModels []Bookmark) error {
        panic("not implemented") // TODO: Implement
}

func (repo *PsqlBookmarkRepository) DeleteWhere(ctx context.Context, columnFilter BookmarkFilter) (numAffectedRecords int, err error) {
        panic("not implemented") // TODO: Implement
}

func (repo *PsqlBookmarkRepository) CountWhere(ctx context.Context, columnFilter BookmarkFilter) int {
        panic("not implemented") // TODO: Implement
}

func (repo *PsqlBookmarkRepository) CountAll(ctx context.Context) int {
        panic("not implemented") // TODO: Implement
}

func (repo *PsqlBookmarkRepository) DoesExist(ctx context.Context, repositoryModels Bookmark) bool {
        panic("not implemented") // TODO: Implement
}

func (repo *PsqlBookmarkRepository) DoesExistWhere(ctx context.Context, columnFilter BookmarkFilter) bool {
        panic("not implemented") // TODO: Implement
}

func (repo *PsqlBookmarkRepository) GetWhere(ctx context.Context, columnFilter BookmarkFilter) []Bookmark {
        panic("not implemented") // TODO: Implement
}

func (repo *PsqlBookmarkRepository) GetFirstWhere(ctx context.Context, columnFilter BookmarkFilter) Bookmark {
        panic("not implemented") // TODO: Implement
}

func (repo *PsqlBookmarkRepository) GetAll(ctx context.Context) []Bookmark {
        panic("not implemented") // TODO: Implement
}
