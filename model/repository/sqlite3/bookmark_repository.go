// Copyright Â© 2021-2022 Jonas Muehlmann
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// THIS CODE IS GENERATED BY GO GENERATE, IT'S TEMPLATE IS /templates/sql_repositories/bookmark_repository.go.tpl

package repository

import (
	"context"
	"database/sql"

	"github.com/JonasMuehlmann/bntp.go/repository"
	"github.com/JonasMuehlmann/optional.go"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/boil"
)

type Sqlite3BookmarkRepository struct {
	db sql.DB
}
type BookmarkField string

var BookmarkFields = struct {
	ID             BookmarkField
	IsRead         BookmarkField
	Title          BookmarkField
	URL            BookmarkField
	BookmarkTypeID BookmarkField
	IsCollection   BookmarkField
	CreatedAt      BookmarkField
	UpdatedAt      BookmarkField
	DeletedAt      BookmarkField
}{
	ID:             "id",
	IsRead:         "is_read",
	Title:          "title",
	URL:            "url",
	BookmarkTypeID: "bookmark_type_id",
	IsCollection:   "is_collection",
	CreatedAt:      "created_at",
	UpdatedAt:      "updated_at",
	DeletedAt:      "deleted_at",
}

var BookmarkFieldsList = []BookmarkField{
	BookmarkField("ID"),
	BookmarkField("IsRead"),
	BookmarkField("Title"),
	BookmarkField("URL"),
	BookmarkField("BookmarkTypeID"),
	BookmarkField("IsCollection"),
	BookmarkField("CreatedAt"),
	BookmarkField("UpdatedAt"),
	BookmarkField("DeletedAt"),
}

var BookmarkRelationsList = []string{
	"BookmarkType",
	"Tags",
}

type BookmarkFilter struct {
	ID             optional.Optional[FilterOperation[int64]]
	IsRead         optional.Optional[FilterOperation[int64]]
	Title          optional.Optional[FilterOperation[null.String]]
	URL            optional.Optional[FilterOperation[string]]
	BookmarkTypeID optional.Optional[FilterOperation[null.Int64]]
	IsCollection   optional.Optional[FilterOperation[int64]]
	CreatedAt      optional.Optional[FilterOperation[string]]
	UpdatedAt      optional.Optional[FilterOperation[string]]
	DeletedAt      optional.Optional[FilterOperation[null.String]]

	BookmarkType optional.Optional[UpdateOperation[*repository.BookmarkType]]
	Tags         optional.Optional[UpdateOperation[repository.TagSlice]]
}

type BookmarkUpdater struct {
	ID             optional.Optional[UpdateOperation[int64]]
	IsRead         optional.Optional[UpdateOperation[int64]]
	Title          optional.Optional[UpdateOperation[null.String]]
	URL            optional.Optional[UpdateOperation[string]]
	BookmarkTypeID optional.Optional[UpdateOperation[null.Int64]]
	IsCollection   optional.Optional[UpdateOperation[int64]]
	CreatedAt      optional.Optional[UpdateOperation[string]]
	UpdatedAt      optional.Optional[UpdateOperation[string]]
	DeletedAt      optional.Optional[UpdateOperation[null.String]]

	BookmarkType optional.Optional[UpdateOperation[*repository.BookmarkType]]
	Tags         optional.Optional[UpdateOperation[repository.TagSlice]]
}

type Sqlite3BookmarkRepositoryHook func(context.Context, Sqlite3BookmarkRepository) error

func (repo *Sqlite3BookmarkRepository) New(args ...any) (Sqlite3BookmarkRepository, error) {
	panic("not implemented") // TODO: Implement
}

func (repo *Sqlite3BookmarkRepository) Add(ctx context.Context, repositoryModels []Bookmark) error {
	tx, err := repo.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	for _, repositoryModel := range repositoryModels {
		err = repositoryModel.Insert(ctx, tx, boil.Infer())
		if err != nil {
			return err
		}
	}

	tx.Commit()

	return nil
}

func (repo *Sqlite3BookmarkRepository) Replace(ctx context.Context, repositoryModels []Bookmark) error {
	tx, err := repo.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	for _, repositoryModel := range repositoryModels {
		_, err = repositoryModel.Update(ctx, tx, boil.Infer())
		if err != nil {
			return err
		}
	}

	tx.Commit()

	return nil
}

func (repo *Sqlite3BookmarkRepository) UpdateWhere(ctx context.Context, columnFilter BookmarkFilter, columnUpdaters map[BookmarkField]BookmarkUpdater) (numAffectedRecords int, err error) {
	// NOTE: This kind of update is inefficient, since we do a read just to do a write later, but at the moment there is no better way
	// Either SQLboiler adds support for this usecase or (preferably), we use the caching and hook system to avoid database interaction, when it is not needed

	// NOTE: Maybe the filter and update operations should be moved to the repository package
	// The repository functions maybe should take repository models as parameters then,
	// the managers take repository models and convert then to repository models before calling the repositories

	// TODO: Implement translator from domainColumnFilter to repositoryColumnFilter and updater

	var modelsToUpdate BookmarkSlice
	var queryFilter qm.QueryMod

	if columnFilter.BookmarkType {

	}

	modelsToUpdate, err = Bookmarks(queryFilter).All(ctx, &repo.db)
}

func (repo *Sqlite3BookmarkRepository) Delete(ctx context.Context, repositoryModels []Bookmark) error {
	panic("not implemented") // TODO: Implement
}

func (repo *Sqlite3BookmarkRepository) DeleteWhere(ctx context.Context, columnFilter BookmarkFilter) (numAffectedRecords int, err error) {
	panic("not implemented") // TODO: Implement
}

func (repo *Sqlite3BookmarkRepository) CountWhere(ctx context.Context, columnFilter BookmarkFilter) int {
	panic("not implemented") // TODO: Implement
}

func (repo *Sqlite3BookmarkRepository) CountAll(ctx context.Context) int {
	panic("not implemented") // TODO: Implement
}

func (repo *Sqlite3BookmarkRepository) DoesExist(ctx context.Context, repositoryModels Bookmark) bool {
	panic("not implemented") // TODO: Implement
}

func (repo *Sqlite3BookmarkRepository) DoesExistWhere(ctx context.Context, columnFilter BookmarkFilter) bool {
	panic("not implemented") // TODO: Implement
}

func (repo *Sqlite3BookmarkRepository) GetWhere(ctx context.Context, columnFilter BookmarkFilter) []Bookmark {
	panic("not implemented") // TODO: Implement
}

func (repo *Sqlite3BookmarkRepository) GetFirstWhere(ctx context.Context, columnFilter BookmarkFilter) Bookmark {
	panic("not implemented") // TODO: Implement
}

func (repo *Sqlite3BookmarkRepository) GetAll(ctx context.Context) []Bookmark {
	panic("not implemented") // TODO: Implement
}
